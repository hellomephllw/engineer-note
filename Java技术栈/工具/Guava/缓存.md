注意上面的scheduleRefresh()方法，这个方法的实现决定了expireAfterWrite和refreshAfterWrite两种过期策略的区别。
两个策略都能保证在本地缓存过期时，只有一个线程去穿透缓存加载后端资源。区别是在加载资源时expireAfterWrite会让所有的线程阻塞等待新值返回,然后返回加载好的新值；而refreshAfterWrite在一个线程去拿新值的同时，其他线程先直接返回旧值，不阻塞。

根据容量取模一定概率回收

如果固定了元素容量，如果容量大小不够，则Guava Cache默认采取了LRU缓存淘汰策略

指定弱引用类型